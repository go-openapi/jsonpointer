name: go-test

on:
  push:
    branches:
      - master

  pull_request:

permissions:
  pull-requests: read
  contents: read

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      -
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
      -
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: stable
          check-latest: true
          cache: true
      -
        name: golangci-lint
        uses: golangci/golangci-lint-action@1e7e51e771db61008b38414a730f564565cf7c20 # v9.2.0
        with:
          version: latest
          only-new-issues: true
          skip-cache: true

  test:
    name: Unit tests
    runs-on: ${{ matrix.os }}
    needs: [lint]

    strategy:
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
        go: ['oldstable', 'stable' ]

    steps:
      -
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
      -
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: '${{ matrix.go }}'
          check-latest: true
          cache: true
      -
        name: Install gotestsum
        uses: go-openapi/gh-actions/install/gotestsum@ca5928fe952ce03d9e6a61a8284a508a9cc8d4f1
      -
        name: Run unit tests
        shell: bash
        run: >
          gotestsum
          --jsonfile 'unit.report.${{ matrix.os }}-${{ matrix.go }}.json'
          --
          -race
          -p 2
          -count 1
          -timeout=20m
          -coverprofile='unit.coverage.${{ matrix.os }}-${{ matrix.go }}.out'
          -covermode=atomic
          -coverpkg="$(go list)"/...
          ./...
      -
        name: Upload coverage artifacts
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          # *.coverage.* pattern is automatically detected by codecov
          path: '**/*.coverage.*.out'
          name: 'unit.coverage.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1
      -
        name: Upload test report artifacts
        # upload report even if test fail. BTW, this is when they are valuable.
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          path: '**/unit.report.*.json'
          name: 'unit.report.${{ matrix.os }}-${{ matrix.go }}'
          retention-days: 1

  test-complete:
    # description: |
    #   Be explicit about all tests being passed. This allows for setting up only a few status checks on PRs.
    name: tests completed
    needs: [test,fuzz-test]
    runs-on: ubuntu-latest
    steps:
      -
        name: Tests completed
        run: |
          echo "::notice title=Success:All tests passed"

  collect-coverage:
    # description: |
    #   Gather, merge then uploads test coverage files from all test jobs (this includes integration tests,
    #   like codegen-test). This reduces the number of failures due to codecov hitting github API rate limit.
    name: collect test coverage
    needs: [test-complete]
    if: ${{ !cancelled() && needs.test-complete.result == 'success' }}
    runs-on: ubuntu-latest
    steps:
      -
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
      -
        name: Download coverage artifacts
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          run-id: "${{ github.run_id }}"
          pattern: "*.coverage.*"
          # artifacts resolve as folders
          path: coverage/
      -
        name: Upload coverage to codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5.5.1
        with:
          name: Aggregated coverage
          # All *.coverage.*.out files uploaded should be detected by the codecov action.
          # NOTE: we lose the flags on individual test reports (e.g. by os, by go version, unit vs integration tests)
          fail_ci_if_error: false
          verbose: false

  collect-reports:
    # description: |
    #   Gather, merge then uploads test report files from unit test jobs.
    #
    #   At this moment test reports are published on both codecov
    #   (see <https://app.codecov.io/gh/go-swagger/go-swagger/tests>) and the github actions UI
    #   (see <https://github.com/go-swagger/go-swagger/actions>).
    name: collect test reports
    needs: [test]
    if: ${{ !cancelled() }}
    runs-on: ubuntu-latest
    steps:
      -
        name: Download test report artifacts
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          run-id: "${{ github.run_id }}"
          pattern: "*.report.*"
          # artifacts resolve as folders
          path: reports/
      -
        name: Install go-junit-report
        uses: go-openapi/gh-actions/install/go-junit-report@ca5928fe952ce03d9e6a61a8284a508a9cc8d4f1
      -
        name: Convert test reports to a merged JUnit XML
        # NOTE: codecov test reports only support JUnit format at this moment. See https://docs.codecov.com/docs/test-analytics.
        # Ideally, codecov improve a bit their platform, so we may only need a single pass to CTRF format.
        #
        # As a contemplated alternative, we could use gotestsum above to produce the JUnit XML directly.
        # At this moment, we keep a json format to dispatch test reports to codecov as well as to CTRF reports.
        #
        # TODO(fredbi): investigate - use mikepenz/action-junit-report@v5, that packages most of the following scripts
        # in a single action. Alternative: for that action.
        run: |
          find reports/ -name \*.json -print0 | xargs -0 cat | go-junit-report -parser gojson -out=reports/junit_report.xml
      -
        name: Upload test results to Codecov
        # This allows for using the test results UI on codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5.5.1
        with:
          files: '**/junit_report.xml'
          report_type: 'test_results'
          fail_ci_if_error: false
          handle_no_reports_found: true
          verbose: true
      -
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: stable
          check-latest: true
          cache: true
      -
        name: Install go-ctrf-json-reporter
        uses: go-openapi/gh-actions/install/go-ctrf-json-reporter@ca5928fe952ce03d9e6a61a8284a508a9cc8d4f1
      -
        name: Convert test reports to CTRF JSON
        # description: |
        #   This step publishes CTRF test reports on github UI (actions)
        run: |
          appName="${{ github.repository }}"
          buildNumber="${{ github.run_id }}"
          appVersion="${{ github.event.pull_request.head.sha }}"
          if [[ -z "${appVersion}" ]] ; then
            # for push events
            appVersion="${{ github.sha }}"
          fi

          # reconstruct platform information from the file name
          while read -r report ; do
            reformated=$(echo "${report##*/}"|sed -E 's/(go)([[:digit:]]+)\.([[:digit:]]+)/\1\2\3/') # e.g. go1.24 becomes go124
            mapfile -d'.' -t -s 2 -n 2 split < <(echo "$reformated") # skip the first 2 parts, stop on 2 more parts
            envstring="${split[0]}"
            osPlatform="${envstring%-*}"
            osRelease="${envstring##*-}"

            # this is a best effort only: tests may be cancelled upstream and produce incorrect reports
            go-ctrf-json-reporter \
              -quiet \
              -appName "${appName}" \
              -appVersion "${appVersion}" \
              -buildNumber "${buildNumber}" \
              -osPlatform "${osPlatform}" \
              -osRelease "${osRelease}" \
              -output "./reports/ctrf_report_${osPlatform}_${osRelease}.json" < "${report}" || true
          done < <(find reports -name \*.json)

      # NOTE: at this moment, we don't upload CTRF reports as artifacts.
      # Some of the CTRF reports are therefore not available (flaky tests, history, ...).
      #
      # See https://github.com/ctrf-io/github-test-reporter?tab=readme-ov-file#report-showcase
      # for more reporting possibilities. At the moment, we keep it simple, as most advanced features
      # require a github token (thus adding the complexity of a separate workflow starting on pull_request_target).
      #
      # For the moment, we are contented with these simple reports. This is an opportunity to compare the insight they
      # provide as compared to what is uploaded to codecov.
      #
      # Codecov analytics are pretty poor at this moment. On the other hand, they manage the bot that pushes back
      # PR comments.
      #
      # They also handle the storage of past test reports, so as to assess flaky tests.
      -
        name: Publish Test Summary Results
        uses: ctrf-io/github-test-reporter@024bc4b64d997ca9da86833c6b9548c55c620e40 # v1.0.26
        with:
          report-path: 'reports/ctrf_report_*.json'
          use-suite-name: true
          summary-report: true             # post a report to the github actions summary
          github-report: true
          failed-folded-report: true

  fuzz-test:
    name: fuzz test
    runs-on: ubuntu-latest
    env:
      CORPUS_MAX_SIZE_MB: 250
      FUZZ_TIME: 1m30s
      FUZZ_MINIMIZE_TIME: 5m
    steps:
      -
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
      -
        uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6.1.0
        with:
          go-version: stable
          check-latest: true
          cache: true
      -
        name: Locate go fuzz cache
        run: |
          GOCACHE=$(go env GOCACHE)
          echo "CORPUS_DIR=${GOCACHE}/fuzz" >> "${GITHUB_ENV}"
      -
        name: Retrieve fuzz corpus from cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          key: ${{ runner.os }}-go-fuzz
          path:
            ${{ env.CORPUS_DIR }}
      -
        name: Manage fuzz corpus cache size
        run: |
          mkdir -p "${CORPUS_DIR}"
          # This script checks that the size of the corpus cache doesn't exceed ${CORPUS_MAX_SIZE_MB},
          # and if it does, it removes all oldest files beyond that size.

          function size() {
            local location=$1
            local unit=$2

            du -s"${unit}" "${location}"|cut -f1
          }

          function purge() {
            local location=$1
            local max_size_b=$2
            declare -i current_size_b=0 file_size_b=0 purged_files=0

            while read -r filename ; do
              file_size_b="$(size "${filename}" "b")"
              ((current_size_b+=file_size_b))

              if [[ ${current_size_b} -le ${max_size_b} ]] ; then
                continue
              fi
              if [[ ${file_size_b} -eq 0 ]] ; then
                continue
              fi

              rm -f "${filename}"
              ((purged_files+=1))
            done < <(find "${location}" -type f -print0 | xargs -0 ls -t)

            echo ${purged_files}
          }

          CURRENT_SIZE_MB="$(size "${CORPUS_DIR}" "m")"
          if [[ "${CURRENT_SIZE_MB}" -lt "${MAX_SIZE_MB}" ]] ; then
            echo "::notice:cache size remains under the accepted size of ${MAX_SIZE_MB} MB: ${CURRENT_SIZE_MB} MB"

            exit 0
          fi

          declare -i max_size_b=$(("${CORPUS_MAX_SIZE_MB}" * 1024 * 1024))
          purged_files=$(purge "${purged_dir}" "${max_size_b}");
          echo "::notice:cache size is ${CURRENT_SIZE_MB} MB: purging oldest files to keep it under ${CORPUS_MAX_SIZE_MB} MB"
          if [[ ${purged_files} -gt 0 ]] ; then
            echo "::notice:removed ${purged_files} files to keep the cache size below ${CORPUS_MAX_SIZE_MB} MB"
          fi
          FINAL_SIZE_MB="$(size "${CORPUS_DIR}" "m")"
          echo "::notice:purged cache size: ${FINAL_SIZE_MB} MB"
      -
        name: Run go fuzz tests
        # TODO(fredbi): ./... is not supported: we should run as a matrix test multiple fuzz tests
        run: >
          go test
          -fuzz=Fuzz
          -run=Fuzz
          -fuzztime='${{ env.FUZZ_TIME }}'
          -fuzzminimizetime='${{ env.FUZZ_MINIMIZE_TIME }}'
          ./...
      -
        name: Upload failed corpus
        if: ${{ failure() }}
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        # TODO(fredbi): ideally, after uploading, we should fire a pull request to add
        # this corpus to testdata.
        with:
          path: ${{ env.CORPUS_DIR }}
          name: '${{ runner.os }}-fuzz-corpus-failure'
          retention-days: 60
      -
        name: Report fuzz corpus cache size
        run: |
          FINAL_SIZE=$(du -m "${CORPUS_DIR}"|cut -f1)
          echo "::notice title=fuzz corpus size:${FINAL_SIZE}MB"
